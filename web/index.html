<html>
<head>
  <style>
  html,
  body {
    width: 100%;
    height: 100%;
    background: #fff;
  }
  body {
    margin: 0;
    overflow: hidden;
  }
  canvas {
    width: 100%;
    height: 100%;
  }
  #container {
    height: 100%;
    box-sizing: border-box;
    padding: 10%;
    background: linear-gradient(rgba(0,0,0,0), rgba(0,0,0,0.1));
  }
  #container .cell {
    height: 100%;
    width: 33%;
    display: inline-block;
    box-sizing: border-box;
    padding: 20px;
    vertical-align: top;
  }
  .cell > div {
    height: 100%;
    width: 100%;
    background: #f9f9f9;
    border: 1px solid #ddd;
  }
  </style>
  <meta charset='UTF-8'>
</head>
<body>

  <div id='container'>
    <div class='cell'>
      <div id='scene-x'></div>
    </div>
    <div class='cell'>
      <div id='scene-z'></div>
    </div>
    <div class='cell'>
      <div id='scene-w'></div>
    </div>
  </div>

  <script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/97/three.min.js'></script>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/gsap/2.1.3/TweenLite.min.js'></script>
  <script src='https://rawgit.com/YaleDHLab/pix-plot/master/assets/js/trackball-controls.js'></script>

  <script type='x-shader/x-vertex' id='vertex-shader'>
  precision highp float;

  uniform mat4 modelViewMatrix;
  uniform mat4 projectionMatrix;

  attribute vec3 position;
  attribute vec3 translation;
  attribute float size;

  varying float vAlpha;

  void main() {
    // set point position
    vec3 pos = position + translation;
    vec4 projected = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
    gl_Position = projected;
    gl_PointSize = size;
    vAlpha = size;
  }
  </script>

  <script type='x-shader/x-fragment' id='fragment-shader'>
  precision highp float;

  varying float vAlpha;

  void main() {
    // make points round; convert [0,1] to [-0.5,0.5] then check if outside radius
    vec2 coord = gl_PointCoord - vec2(0.5);
    if(length(coord) > 0.5) discard;

    // set the vertex color
    gl_FragColor = vec4(0.0, 0.0, 0.0, vAlpha);
  }
  </script>

  <script>

  // generate a scene object
  var scene = new THREE.Scene();

  // generate a camera
  var container = getContainer();
  var aspectRatio = container.w / container.h;
  var camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.01, 1000);
  camera.position.set(0, 0.7, -1);

  // generate a renderer
  var renderer = new THREE.WebGLRenderer({antialias: true, alpha: true,});
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(container.w, container.h);
  container.elem.appendChild(renderer.domElement);

  // add controls
  var controls = new THREE.TrackballControls(camera, renderer.domElement);
  controls.target.set(0.02, 0.15, .36);

  /**
  * Helpers
  **/

  function getContainer() {
    var elem = document.querySelector('#scene-x');
    return {
      elem: elem,
      w: elem.clientWidth,
      h: elem.clientHeight,
    }
  }

  function get(url, onSuccess, onErr) {
    var xmlhttp = new XMLHttpRequest();
    xmlhttp.onreadystatechange = function() {
      if (xmlhttp.readyState == XMLHttpRequest.DONE) {
        if (xmlhttp.status === 200) {
          if (onSuccess) onSuccess(JSON.parse(xmlhttp.responseText))
        } else {
          if (onErr) onErr(xmlhttp)
        }
      };
    };
    xmlhttp.open('GET', url, true);
    xmlhttp.send();
  };

  window.addEventListener('resize', function() {
    var container = getContainer();
    camera.aspect = container.w / container.h;
    camera.updateProjectionMatrix();
    renderer.setSize(container.w, container.h);
  })

  /**
  * Custom
  **/

  // model data
  var allX = [],
      allZ = [],
      allW = [],
      verts = 52,
      dims = 3,
      xScalar = 1,
      framesToShow = 30;

  // gl
  var geometry = new THREE.InstancedBufferGeometry(),
      mesh,
      material,
      translations = new Float32Array(verts * dims * framesToShow),
      translationsIter,
      BA = THREE.BufferAttribute,
      IBA = THREE.InstancedBufferAttribute,
      ARR = Float32Array;

  // initialize the geometry
  get('http://localhost:5050/api/frame', function(data) {
    allX.unshift(data.x);
    allZ.unshift(data.z);
    allW.unshift(data.w);

    geometry.addAttribute('position',
      new BA(new ARR([0, 0, 0]), 3));
    geometry.addAttribute('translation',
      new IBA(getTranslations(), 3, true, 1));
    geometry.addAttribute('size',
      new IBA(getSizes(), 1, true, 1));

    material = new THREE.RawShaderMaterial({
      vertexShader: document.querySelector('#vertex-shader').textContent,
      fragmentShader: document.querySelector('#fragment-shader').textContent,
      transparent: true,
      blending: THREE.NormalBlending,
    });
    material.transparent = true;

    mesh = new THREE.Points(geometry, material);
    mesh.name = 'x';
    mesh.rotation.x = -Math.PI / 2;
    mesh.frustumCulled = false; // prevent mesh from clipping on drag
    scene.add(mesh);
  })

  function getTranslations() {
    translationsIter = 0;
    for (var i=0; i<allX.length; i++) {
      var x = allX[i];
      for (var j=0; j<x.length; j++) {
        for (var k=0; k<dims; k++) {
          translations[translationsIter++] = x[j][k] * xScalar;
        }
      }
    }
    return translations;
  }

  function getSizes() {
    var buff = new ARR(framesToShow * verts);
    for (var i=0; i<buff.length; i++) {
      buff[i] = ((1.0 - (Math.floor(i/verts) / framesToShow)) ** 3) * 10;
    }
    return buff;
  }

  function loadFrame() {
    get('http://localhost:5050/api/frame', function(data) {
      while (allX.length > framesToShow) allX = allX.slice(0, framesToShow)
      while (allZ.length > framesToShow) allZ = allZ.slice(0, framesToShow)
      while (allW.length > framesToShow) allW = allW.slice(0, framesToShow)

      // push so the rendering draws older frames first then newer frames
      allX.unshift(data.x);
      allZ.unshift(data.z);
      allW.unshift(data.w);

      translations = getTranslations();
      mesh.geometry.attributes.translation.array = translations;
      mesh.geometry.attributes.translation.needsUpdate = true;
    })
  }

  // add grid helper
  var gridHelper = new THREE.GridHelper(100, 100);
  gridHelper.name = 'grid-helper';
  scene.add(gridHelper);

  // render loop
  function render() {
    requestAnimationFrame(render);
    if (mesh) loadFrame();
    renderer.render(scene, camera);
    controls.update();
  };

  render();
  </script>
</body>
</html>
